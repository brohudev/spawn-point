import os

# This module is internal to utils and should only be imported by generate.py
__all__ = []

def _load_fragment(fragment_type, name):
     """Load a fragment file if it exists, return empty string if not."""
     # Calculate the fragments directory path relative to this file
     fragments_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'fragments')
     
     # For fragments in root directory, ignore the fragment_type
     if not fragment_type:
          fragment_path = os.path.join(fragments_dir, f"{name}.py")
     else:
          fragment_path = os.path.join(fragments_dir, fragment_type, f"{name}.py")
     
     print(f"DEBUG: Looking for fragment at {fragment_path}")
     print(f"DEBUG: Current directory: {os.getcwd()}")
     print(f"DEBUG: File directory: {os.path.dirname(os.path.abspath(__file__))}")
     
     try:
          if os.path.exists(fragment_path):
               with open(fragment_path, 'r') as f:
                    return f.read()
          else:
               print(f"Fragment not found: {fragment_path}")
               print(f"Available fragments in {os.path.dirname(fragment_path)}:")
               try:
                    files = os.listdir(os.path.dirname(fragment_path))
                    for f in files:
                         print(f"  - {f}")
               except Exception as e:
                    print(f"Could not list directory: {str(e)}")
          return f"# {name} fragment not found\nraise RuntimeError(f\"Required fragment '{name}' not found in {fragment_path}\")\n"
     except Exception as e:
          error_msg = f"Error loading fragment {name} from {fragment_path}: {str(e)}"
          print(error_msg)
          return f"# Error loading {name} fragment\nraise RuntimeError(\"{error_msg}\")\n"

def _generate_header(os_full, proj_type, ci_option, deploy_option):
     """Generate the script header with metadata."""
     header = "#!/usr/bin/env python3\n"
     header += f"# Generated by Spawnpoint for {os_full}/{proj_type}\n"
     header += f"# CI: {ci_option}, Deploy: {deploy_option}\n\n"
     return header

def _generate_imports():
     """Generate the import statements for the script."""
     return "import os\nimport sys\nimport argparse\n\n"

def _generate_os_verification(os_full):
     """Generate the OS verification section."""
     # Load the platform_check directly from fragments directory
     platform_check = _load_fragment('', 'platform_check')
     
     return platform_check + "\n"

def _generate_project_setup(proj_type):
     """Generate the project setup section."""
     # Convert frontend/backend to front/back for fragment names
     fragment_name = proj_type.replace('front', 'front').replace('back', 'back')
     return "    # Project setup\n" + _load_fragment('', f"{fragment_name}_setup")

def _generate_ci_setup(ci_option):
     """Generate the CI setup section if needed."""
     if ci_option == 'none':
          return ""
     return "\n    # CI setup\n" + _load_fragment('ci', f"{ci_option}_setup")

def _generate_deploy_setup(deploy_option):
     """Generate the deployment setup section if needed."""
     if deploy_option == 'none':
          return ""
     return "\n    # Deployment setup\n" + _load_fragment('deploy', f"{deploy_option}_setup")

def _generate_main_function(os_full, proj_type, fragment_path):
     """Generate the main function definition."""
     main_func = "\ndef main():\n"
     main_func += f"    print(\"Setting up {proj_type}end project for {os_full}\")\n"
     

     main_func += f"    verify_platform(\"{os_full}\")\n\n"     
     return main_func

def _generate_entrypoint(ci_option, deploy_option):
     """Generate the script entrypoint."""
     entrypoint = "\nif __name__ == \"__main__\":\n"
     entrypoint += "    parser = argparse.ArgumentParser(description='Project setup script')\n"
     entrypoint += f"    parser.add_argument('--ci', default='{ci_option}', help='CI option')\n"
     entrypoint += f"    parser.add_argument('--deploy', default='{deploy_option}', help='Deployment option')\n"
     entrypoint += "    args = parser.parse_args()\n"
     entrypoint += "    main()\n"
     return entrypoint

def _process_project_fragment(proj_type):
    """Load and process the project setup fragment if it exists."""
    fragment_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 
                              f'fragments/{proj_type}_setup.py')
    
    fragment_content = ""
    has_setup_func = False
    setup_func_name = f"setup_{proj_type}"
    setup_fragment = ""
    
    if os.path.exists(fragment_path):
        with open(fragment_path, 'r') as f:
            setup_fragment = f.read()
            fragment_content = "\n# Project setup fragment\n" + setup_fragment + "\n"
            has_setup_func = setup_func_name in setup_fragment
            
    return fragment_content, has_setup_func, setup_func_name, setup_fragment, fragment_path

def _generate_script_sections(os_full, proj_type, ci_option, deploy_option):
    """Generate all script sections after the main function."""
    fragment_content, has_setup_func, setup_func_name, setup_fragment, fragment_path = _process_project_fragment(proj_type)
    
    # Start with an empty script
    script_sections = ""
    
    # Add project setup
    if os.path.exists(fragment_path) and has_setup_func:
        script_sections += f"\n    {setup_func_name}()\n"
    else:
        # Add the regular setup sections with proper indentation
        project_setup = _generate_project_setup(proj_type)
        script_sections += project_setup.replace('\n', '\n    ')
    
    # Add CI and deployment setup if specified
    ci_setup = _generate_ci_setup(ci_option)
    if ci_setup:
        script_sections += ci_setup.replace('\n', '\n    ')
    
    # Add deployment setup if specified
    deploy_setup = _generate_deploy_setup(deploy_option)
    if deploy_setup:
        script_sections += deploy_setup.replace('\n', '\n    ')
    
    return script_sections, fragment_content, fragment_path
